/*******************************************************************************
 * ADSync4J (https://github.com/zagyi/adsync4j)
 *
 * Copyright (c) 2013 Balazs Zagyvai
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Balazs Zagyvai
 ***************************************************************************** */

/**
 * WHY ARE THERE TWO BUILD SCRIPTS IN THIS PROJECT? (build.gradle and buildSrc.gradle)
 *
 * The buildSrc project has a distinguished role in Gradle. It is meant to hold code that is commonly used in build scripts
 * of multiple subprojects. Instead of copying common logic and utility functions into each subproject that uses it,
 * you can simply put common code in buildSrc, and Gradle will make sure it's compiled first and made available for build scripts
 * in other projects. When building the buildSrc project, Gradle looks for a build script with the default file name
 * ('build.gradle'). So that's why we have 'build.gradle', which is half of the story.
 *
 * This works perfectly fine, however the implicit dependency of "normal" subprojects on the buildSrc project is not known to the
 * IDE. That becomes a problem, when we use any code from buildSrc in other build scripts, because the IDE won't recognize where
 * that code is supposed to come from, so proper IDE support (e.g. code completion) won't be available.
 * In order to fix this, we would need to make a normal IDE module for the buildSrc project and declare an explicit dependency
 * on it from every other project. To achieve this we have to elevate buildSrc to the level of an ordinary subproject, but how
 * can we do that? Simply enlist buildSrc in the included projects in /settings.gradle, and create a second build script according
 * to our own build script naming convention "<project's name>.gradle" (this convention is also established in /settings.gradle).
 * So that's why we have 'buildSrc.gradle'.
 *
 * The result of this weird setup is that the buildSrc project is always built twice:
 *  1. First, because (by convention) Gradle builds it to make common build logic available to build scrips in the entire
 *  project (build.gradle is used here).
 *  2. Second, because it's explicitly included in the list of subprojects in settings.gradle (buildSrc.gradle is used here.)
 *
 * This _is_ a hack, but it's still better than to forgo proper IDE support when using common code from buildSrc.
 * To reduce the overhead of the second build, buildSrc.gradle overrides all tasks with a no-op action except for 'idea' and
 * 'cleanIdea' -- after all, we only want an IntelliJ IDEA module generated for the project!
 */

import org.adsync4j.gradle.Libs

Project buildSrc = project

buildSrc.dependencies.with {
    add('provided', Libs.groovy)
    add('provided', Libs.guava)
    add('provided', Libs.slf4jApi)
}

def nonIdeaPluginTasks = buildSrc.tasks.findAll { !it.name.toLowerCase().contains('idea') }

nonIdeaPluginTasks.each {
    buildSrc.tasks.create(overwrite: true, name: it.name).dependsOn = []
}
